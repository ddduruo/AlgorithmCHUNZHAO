学习笔记
1. 移动零
  方法1： 遍历整个数组，遇到零，则删除，数组后面补0 （时间复杂度o(n2)）
  方法2： 增加一个临时变量j，作为下一个不为0位置，遍历整个数组，遇到不为0的值，跟nums[j],进行交换 (时间复杂度o(n)) 推荐
2. 合并两个数组
  方法1： 暴力法 直接合并两个数组，再排序 时间复杂度(o(nlong));
  方法2： 双指针法，因为是两个有序数组，分别指定i,j两个指针为两个数组的最后一位，再定义合并后的末尾位置k
         两个数组从最末端开始比较，把大的值放到k的位置上。剩余的值，直接遍历k，再赋值 （时间复杂度o(n)）
3. 两数之和
  方法1： 暴力枚举 枚举每一个数x,寻找数组中是否存在target - x 时间复杂度o(n2)
  方法2： 利用哈希表的形式， 能够快速寻找数组中是否存在目标元素，如果存在找出他的索引
4. 旋转数组
  方法1： 利用javascript API Array.splice()
  方法2： 补位 倒序遍历，数组增加k位整体后移。指针到k后，把[n, n + k]位移回[0, k]。截断到n
             取余：当k>数组长度，测试用例[1, 2] 3等同于[1, 2] 1 3 / 2取余即可
  方法3：原数组翻转 → [0, k)翻转 → [k, 数组长度)翻转
  方法4：利用最小公约数

5. 合并两个有序链表
  方法1： 双指针法 设定一个哨兵节点cur 遍历l1，l2, 比较这两个数值，cur -> 较小的值 最后判断谁不为空 直接cur-> 链表
  方法2： 递归法 递归比较查看两个链表哪个元素先小 就斩断此元素位置链条⛓️连接到另一链表上 如此也不需要另外开辟存储空间
              斩断后 重连铁链的动作因为要自动非人工 所以需要程序自己调用自己 即为递归
              斩断后需要连的结点 通过 return 最小结点 即动态更新 斩断结点位置
              随时连接下一个符合要求的位置（x.next = 求下一个需要连接的结点位置(即程序自动搜索即递归) && x = 下一个需要连接的结点位置）
              返回修改后的 l1头结点的链表 或 l2头结点的链表
6. 删除排序数组中的重复项
  方法1： 用一个读指针，一个写指针遍历数组。遇到重复的元素 读指针 就继续前移。遇到不同的元素 写指针 就前移一步，写入元素

   